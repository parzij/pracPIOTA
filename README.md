Ниже приведён полный текст отчёта, который можно использовать для двух файлов: **документ Word (DOCX)** и **PDF**. Вам остаётся лишь скопировать содержание в текстовый редактор (например, Microsoft Word), проставить нумерацию страниц, сохранить сначала в **.docx**, а затем экспортировать/печать в **PDF**.

---

# ДЗ-1. Проектирование и реализация конечного распознавателя  
**Вариант:** «Распознавать троичные числа, **не** кратные 11»  
**Студент:** *Фамилия Имя Отчество*, группа ***XX***  

---

## 1. Постановка задачи

Необходимо построить и реализовать программу, моделирующую **детерминированный конечный автомат (ДКА)**, распознающий **все троичные числа, не делящиеся на 11** (в десятичной системе). То есть, если строка \(w\) из символов \(\{0,1,2\}\) задаёт в троичной системе число, которое в десятичном виде **не** кратно 11, автомат должен выдать результат «Yes»; если кратно – «No».

**Программа** должна:  
1. Запрашивать у пользователя входное слово \(w\).  
2. Проверять принадлежность всех символов входного слова алфавиту \(\{0,1,2\}\). Если встречается недопустимый символ, предложить повторить ввод или завершить программу.  
3. Пошагово обрабатывать цепочку, выводя на экран переходы (какой символ прочитан, из какого состояния в какое перешли).  
4. По окончании сообщать результат: **Yes** (если число не кратно 11) или **No** (если кратно).  
5. Предлагать пользователю либо снова ввести слово, либо выйти из программы.

---

## 2. Словесное описание автомата

Для распознавания «троичное число не кратно 11» достаточно хранить в состоянии автомата текущий **остаток** от деления на 11. Так как 11 – фиксировано, возможны остатки \(0,1,2,\dots,10\).  

- Начинаем в состоянии \(q_0\), соответствующем остатку «0».  
- Когда поступает очередной символ (одна из цифр 0,1,2), считаем, что текущее число (в троичной записи) умножается на 3 и прибавляется эта цифра. Остаток тоже меняется по формуле:  
  \[
  r_{\text{new}} = (3 \times r_{\text{old}} + d)\;\bmod\;11,
  \]
  где \(d \in \{0,1,2\}\).  
- В конце чтения:  
  - если остаток \(=0\), число кратно 11 → «No»;  
  - иначе → «Yes».

Таким образом, **состояний** у автомата ровно 11 (\(q_0\) … \(q_{10}\)), где \(q_r\) означает «остаток = r».

Начальное состояние: \(q_0\) (остаток 0).  
Принимающие: все \(q_r\), кроме \(q_0\). То есть \(\{q_1,q_2,\dots,q_{10}\}\).

---

## 3. Формальное описание распознавателя

### 3.1. Пятёрка множеств

Наш ДКА задаётся:
\[
(K,\;\Sigma,\;\delta,\;s_0,\;F),
\]
где  
1. \(K = \{q_0,\,q_1,\dots,q_{10}\}\) – множество состояний.  
2. \(\Sigma = \{\,0,1,2\}\) – входной алфавит.  
3. \(\delta: K \times \Sigma \to K\) – функция переходов, \(\delta(q_r,d)=q_{((3r + d)\bmod11)}\).  
4. \(s_0 = q_0\) – начальное состояние.  
5. \(F = \{\,q_1,q_2,\dots,q_{10}\}\) – множество допускающих состояний.

### 3.2. Таблица переходов

Таблица 1 отражает функцию \(\delta\). В строках – текущее состояние \(q_r\). В столбцах – входные символы '0','1','2'. Последний столбец указывает, является ли состояние принимающим (Yes) или нет (No).

**Таблица 1 – Функция переходов автомата**

| Состояние \(q_r\) | При '0'         | При '1'         | При '2'         | Accept? |
|-------------------|----------------|----------------|----------------|:--------|
| \(q_0\) (r=0)  | \(q_0\) (0)    | \(q_1\) (1)    | \(q_2\) (2)    | No      |
| \(q_1\) (r=1)  | \(q_3\) (3)    | \(q_4\) (4)    | \(q_5\) (5)    | Yes     |
| \(q_2\) (r=2)  | \(q_6\) (6)    | \(q_7\) (7)    | \(q_8\) (8)    | Yes     |
| \(q_3\) (r=3)  | \(q_9\) (9)    | \(q_{10}\) (10)| \(q_0\) (0)    | Yes     |
| \(q_4\) (r=4)  | \(q_1\) (1)    | \(q_2\) (2)    | \(q_3\) (3)    | Yes     |
| \(q_5\) (r=5)  | \(q_4\) (4)    | \(q_5\) (5)    | \(q_6\) (6)    | Yes     |
| \(q_6\) (r=6)  | \(q_7\) (7)    | \(q_8\) (8)    | \(q_9\) (9)    | Yes     |
| \(q_7\) (r=7)  | \(q_{10}\)(10) | \(q_0\) (0)    | \(q_1\) (1)    | Yes     |
| \(q_8\) (r=8)  | \(q_2\) (2)    | \(q_3\) (3)    | \(q_4\) (4)    | Yes     |
| \(q_9\) (r=9)  | \(q_5\) (5)    | \(q_6\) (6)    | \(q_7\) (7)    | Yes     |
| \(q_{10}\)(r=10)| \(q_8\) (8)    | \(q_9\) (9)    | \(q_{10}\)(10) | Yes     |

### 3.3. Диаграмма переходов

На схеме (Рисунок 1) каждая вершина – это \(q_r\). Из каждой вершины по символам '0','1','2' выходит дуга к следующему состоянию \(\delta(q_r,d)\). Начальное состояние \(q_0\) помечаем стрелкой «start → q0», принимающие (Yes) – двойная окружность.

```
q0 --0--> q0   q0 --1--> q1   q0 --2--> q2
q1 --0--> q3   q1 --1--> q4   q1 --2--> q5
q2 --0--> q6   q2 --1--> q7   q2 --2--> q8
q3 --0--> q9   q3 --1--> q10  q3 --2--> q0
q4 --0--> q1   q4 --1--> q2   q4 --2--> q3
q5 --0--> q4   q5 --1--> q5   q5 --2--> q6
q6 --0--> q7   q6 --1--> q8   q6 --2--> q9
q7 --0--> q10  q7 --1--> q0   q7 --2--> q1
q8 --0--> q2   q8 --1--> q3   q8 --2--> q4
q9 --0--> q5   q9 --1--> q6   q9 --2--> q7
q10--0--> q8   q10--1--> q9   q10--2--> q10
```
**Рис.1 – Диаграмма переходов**  

---

## 4. Набор тестов (ручная прогонка)

Ниже приведены несколько тестов с пятимя-шестью цифрами; укажем и краткий (либо детальный) пошаговый разбор.

**Тест A**: `22011`  
- Троичная интерпретация: \(2\cdot3^4 +2\cdot3^3 +0\cdot3^2 +1\cdot3^1 +1\cdot3^0=220\).  
- \(220 \mod 11=0\) → число кратно 11 → ожидается **No**.  
- Пошагово:  
  - \(q_0\) --'2'--> \(q_2\)  
  - \(q_2\) --'2'--> \(q_8\)  
  - \(q_8\) --'0'--> \(q_2\)  
  - \(q_2\) --'1'--> \(q_7\)  
  - \(q_7\) --'1'--> \(q_0\)  (остаток=0) → итоговое состояние \(q_0\) ⇒ No  

**Тест B**: `21102`  
- \(=200\) десятичное, \(200\mod11=2\neq0\) → **Yes**.

**Тест C**: `01222`  
- \(0\cdot3^4 +1\cdot3^3 +2\cdot3^2 +2\cdot3^1 +2\cdot3^0=53\). \(53\mod11=9\neq0\). Ожидаем **Yes**.

**Тест D**: `11100`  
- \(1\cdot3^4 +1\cdot3^3 +1\cdot3^2 +0 +0=117\). \(117\mod11=7\neq0\). Ожидаем **Yes**.

**Тест E**: `222222`  
- \(=728\). \(728\mod11=2\neq0\). Ожидаем **Yes**.

(Результаты совпадают с теоретическими ожиданиями.)

---

## 5. Скриншоты выполнения программы

Ниже демонстрируем пример, как программа может печатать шаги (на примере `22011`):

```
Введите входное слово: 22011
2: q0 -> q2
2: q2 -> q8
0: q8 -> q2
1: q2 -> q7
1: q7 -> q0
- No
Повторить ввод? (Y/N): 
```

Аналогично для `21102`:

```
Введите входное слово: 21102
2: q0 -> q2
1: q2 -> q7
1: q7 -> q0
0: q0 -> q0
2: q0 -> q2
- Yes
Повторить ввод? (Y/N):
```

---

## 6. Структура данных

Основу хранения переходов автомата составляет **двумерный массив** `delta[11][3]`:
- Первая координата – номер состояния (остатка) \(\{0,\dots,10\}\).
- Вторая координата – входной символ (0,1,2).
- Значение – новое состояние.

Например:
```cpp
int delta[11][3] = {
  {0,1,2},  // переходы из q0
  {3,4,5},  // q1
  {6,7,8},  // q2
  {9,10,0}, // q3
  ...
  {8,9,10}  // q10
};
```
Это гарантирует неизбыточное хранение всех переходов (ровно 11×3=33 элемента).

---

## 7. Словесное описание реализации шага работы

При обработке одного символа:
1. Считываем текущий символ `ch`.
2. Проверяем, что `ch ∈ {0,1,2}`.
3. Переводим в число `digit = ch - '0'`.
4. Выполняем `newState = delta[currentState][digit]`.
5. Выводим:  
   ```
   ch: q<currentState> -> q<newState>
   ```
6. Переходим `currentState = newState`.

После всех символов, если `currentState == 0`, то вывод `No`, иначе `Yes`.

---

## 8. Листинг программы на C++

Ниже приведён **полный** пример программы с комментариями и пошаговым выводом:

```cpp
/*************************************************************
 * ДЗ-1. Проектирование и реализация конечного распознавателя
 * Вариант:  "Троичное число НЕ кратно 11"
 *
 * Студент: Фамилия И.О., Группа: XXX
 *
 * Программа считывает цепочки (из символов {0,1,2}),
 * пошагово пропускает их через ДКА с 11 состояниями (q0..q10),
 * выводит каждую итерацию, в конце выдает Yes (не кратно 11)
 * или No (кратно 11). При неправильном вводе запрашивает
 * повторный ввод.
 *************************************************************/

#include <iostream>
#include <string>
#include <limits>

/*
 * Функция initDelta(int delta[11][3])
 * -----------------------------------
 * Инициализирует таблицу переходов автомата.
 * delta[r][d] - номер нового состояния при
 *   состоянии r и входном символе d (0..2).
 */
void initDelta(int delta[11][3]) {
    // q0
    delta[0][0] = 0;  delta[0][1] = 1;  delta[0][2] = 2;
    // q1
    delta[1][0] = 3;  delta[1][1] = 4;  delta[1][2] = 5;
    // q2
    delta[2][0] = 6;  delta[2][1] = 7;  delta[2][2] = 8;
    // q3
    delta[3][0] = 9;  delta[3][1] = 10; delta[3][2] = 0;
    // q4
    delta[4][0] = 1;  delta[4][1] = 2;  delta[4][2] = 3;
    // q5
    delta[5][0] = 4;  delta[5][1] = 5;  delta[5][2] = 6;
    // q6
    delta[6][0] = 7;  delta[6][1] = 8;  delta[6][2] = 9;
    // q7
    delta[7][0] = 10; delta[7][1] = 0;  delta[7][2] = 1;
    // q8
    delta[8][0] = 2;  delta[8][1] = 3;  delta[8][2] = 4;
    // q9
    delta[9][0] = 5;  delta[9][1] = 6;  delta[9][2] = 7;
    // q10
    delta[10][0] = 8; delta[10][1] = 9; delta[10][2] = 10;
}

/*
 * Функция checkInput(const std::string &input)
 * --------------------------------------------
 * Проверяет, что все символы входной строки
 * принадлежат {0,1,2}. Возвращает true/false.
 */
bool checkInput(const std::string &input) {
    for (char c : input) {
        if (c != '0' && c != '1' && c != '2') {
            return false;
        }
    }
    return true;
}

/*
 * Функция processSymbol(int curState, char symbol,
 *                      const int delta[11][3])
 * ------------------------------------------------
 * Реализует один шаг: по текущему состоянию и символу
 * вычисляет новое состояние. Выводит пошаговый результат.
 * Возвращает новое состояние.
 */
int processSymbol(int curState, char symbol,
                  const int delta[11][3]) {
    int d = symbol - '0'; // преобразуем '0','1','2' в 0,1,2
    int newState = delta[curState][d];
    // Печать шага:
    std::cout << symbol << ": q" << curState
              << " -> q" << newState << "\n";
    return newState;
}

int main() {
    std::cout << "----- ДЗ-1: Конечный распознаватель -----\n"
              << "Вариант: троичное число не кратно 11\n\n";
    
    // 1) Инициализируем таблицу переходов
    int delta[11][3];
    initDelta(delta);

    while (true) {
        // 2) Запрашиваем ввод
        std::cout << "Введите входное слово (из '0','1','2')\n"
                  << "или пустую строку для выхода: ";
        std::string input;
        std::getline(std::cin, input);
        if (input.empty()) {
            std::cout << "Выход из программы.\n";
            break;
        }

        // 3) Проверка ввода
        if (!checkInput(input)) {
            std::cout << "Ошибка: недопустимый символ.\n";
            std::cout << "Повторить ввод? (Y/N): ";
            char ans;
            std::cin >> ans;
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
            if (ans != 'Y' && ans != 'y') {
                std::cout << "Выход.\n";
                break;
            }
            continue;
        }

        // 4) Пошаговая обработка
        int curState = 0; // q0
        for (char c : input) {
            curState = processSymbol(curState, c, delta);
        }

        // 5) Определяем результат (Yes/No)
        if (curState == 0) {
            std::cout << "- No\n";
        } else {
            std::cout << "- Yes\n";
        }

        // 6) Спросим, повторить ли ввод:
        std::cout << "Повторить ввод? (Y/N): ";
        char rep;
        std::cin >> rep;
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        if (rep != 'Y' && rep != 'y') {
            std::cout << "Завершение.\n";
            break;
        }
    }

    return 0;
}
```

### Ключевые моменты кода

1. **`initDelta`**: инициализация массива переходов \(\delta\).  
2. **`checkInput`**: проверка принадлежности символов строке алфавита \(\{0,1,2\}\).  
3. **`processSymbol`**: реализация одного шага, выводит текущее состояние и новое.  
4. **Пошаговый вывод**: для каждого символа печатаем переход.  
5. **Итог**: если итоговое состояние \(=0\), вывод No, иначе Yes.  

---

# Заключение

1. **Проектирование автомата**: Опирается на хранение остатка \(\bmod 11\).  
2. **Словесное и формальное описание**: включают логику, пятёрку множеств, таблицу переходов, диаграмму.  
3. **Тесты**: проверены на разных входных строках, в том числе 5–6 символов; результат согласуется с теорией.  
4. **Программа** полностью соответствует требованиям (пошаговый вывод, проверка символов, диалог и т. д.).  

**Конец отчёта.**  

---

## Как сформировать Word и PDF

1. **Word (DOCX)**:  
   - Скопируйте весь текст этого отчёта в документ Microsoft Word или аналогичный редактор.  
   - Отформатируйте по своему усмотрению (заголовки, нумерация страниц, подписи рисунков и таблиц).  
   - Сохраните как **.docx** (например, `ДЗ-1_Группа_ФИО_Вариант.docx`).  

2. **PDF**:  
   - В Word выполните «Сохранить как» → «PDF» (или «Печать в PDF»).  
   - Получите файл **.pdf** (например, `ДЗ-1_Группа_ФИО_Вариант.pdf`).  

Готово!
